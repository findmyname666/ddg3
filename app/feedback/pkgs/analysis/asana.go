package analysis

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"time"

	"github.com/findmyname666/ddg3/feedback/pkgs/db"
)

const (
	asanaAPIBaseURL     = "https://app.asana.com/api/1.0"
	asanaTasksEndpoint  = "/tasks"
	asanaRequestTimeout = 30 * time.Second
)

// AsanaTaskRequest represents the request body for creating an Asana task
type AsanaTaskRequest struct {
	Data AsanaTaskData `json:"data"`
}

// AsanaTaskData contains the task details
type AsanaTaskData struct {
	Workspace string   `json:"workspace"`           // Required: workspace GID
	Name      string   `json:"name"`                // Required: task name
	Notes     string   `json:"notes,omitempty"`     // Optional: task description
	Completed bool     `json:"completed,omitempty"` // Optional: completion status
	Projects  []string `json:"projects,omitempty"`  // Optional: project GIDs to add task to
}

// AsanaTaskResponse represents the response from Asana API
type AsanaTaskResponse struct {
	Data AsanaTaskResponseData `json:"data"`
}

// AsanaTaskResponseData contains the created task details
type AsanaTaskResponseData struct {
	GID string `json:"gid"`
}

// FeedbackSummary contains the aggregated feedback data
type FeedbackSummary struct {
	PositiveCount   int64
	NegativeCount   int64
	Total           int64
	PositivePercent float64
	NegativePercent float64
}

// AsanaClient handles communication with Asana API
type AsanaClient struct {
	token        string
	workspaceGID string
	projectGID   string
	httpClient   *http.Client
	baseURL      string
}

// newAsanaClient creates a new Asana client
func newAsanaClient(token, workspaceGID, projectGID string) *AsanaClient {
	return &AsanaClient{
		token:        token,
		workspaceGID: workspaceGID,
		projectGID:   projectGID,
		httpClient:   &http.Client{Timeout: asanaRequestTimeout},
		baseURL:      asanaAPIBaseURL,
	}
}

// createAsanaTask creates a task in Asana with the aggregation results
func (a *Aggregator) createAsanaTask(
	ctx context.Context,
	counts *db.CountFeedbackBySentimentRow,
	windowStart, windowEnd time.Time,
) (string, error) {
	// Skip if no Asana credentials (workspace is required)
	if a.asanaToken == "" || a.asanaWorkspace == "" {
		return "", fmt.Errorf("asana credentials not provided")
	}

	// Calculate summary
	summary := calculateFeedbackSummary(counts)
	if summary.Total == 0 {
		slog.Info("No feedback to report, skipping Asana task creation")

		return "", nil
	}

	// Create Asana client
	client := newAsanaClient(a.asanaToken, a.asanaWorkspace, a.asanaProject)

	// Create task
	taskGID, err := client.createTask(ctx, summary, windowStart, windowEnd)
	if err != nil {
		return "", err
	}

	slog.Info("Asana task created successfully",
		"task_gid", taskGID,
		"positive", summary.PositiveCount,
		"negative", summary.NegativeCount)

	return taskGID, nil
}

// calculateFeedbackSummary computes totals and percentages from feedback counts
func calculateFeedbackSummary(counts *db.CountFeedbackBySentimentRow) *FeedbackSummary {
	total := counts.PositiveCount + counts.NegativeCount

	summary := FeedbackSummary{
		PositiveCount: counts.PositiveCount,
		NegativeCount: counts.NegativeCount,
		Total:         total,
	}

	if total > 0 {
		summary.PositivePercent = (float64(counts.PositiveCount) / float64(total)) * 100
		summary.NegativePercent = (float64(counts.NegativeCount) / float64(total)) * 100
	}

	return &summary
}

// formatTaskName creates the Asana task title
func formatTaskName(windowEnd time.Time) string {
	return fmt.Sprintf("Daily Feedback Summary - %s", windowEnd.Format("2006-01-02"))
}

// formatTaskNotes creates the Asana task description
func formatTaskNotes(summary *FeedbackSummary, windowStart, windowEnd time.Time) string {
	return fmt.Sprintf(`Feedback Summary Report

Window: %s to %s (UTC)

Results:
• Positive: %d (%.1f%%)
• Negative: %d (%.1f%%)
• Total: %d

This report was automatically generated by the feedback analysis job.`,
		windowStart.UTC().Format("2006-01-02 15:04"),
		windowEnd.UTC().Format("2006-01-02 15:04"),
		summary.PositiveCount,
		summary.PositivePercent,
		summary.NegativeCount,
		summary.NegativePercent,
		summary.Total,
	)
}

// buildTaskRequest creates an Asana task request
func (c *AsanaClient) buildTaskRequest(
	summary *FeedbackSummary,
	windowStart, windowEnd time.Time,
) AsanaTaskRequest {
	taskData := AsanaTaskData{
		Workspace: c.workspaceGID,
		Name:      formatTaskName(windowEnd),
		Notes:     formatTaskNotes(summary, windowStart, windowEnd),
		Completed: false,
	}

	// Add project if specified
	if c.projectGID != "" {
		taskData.Projects = []string{c.projectGID}
	}

	return AsanaTaskRequest{
		Data: taskData,
	}
}

// createTask creates a task in Asana and returns the task GID
func (c *AsanaClient) createTask(
	ctx context.Context,
	summary *FeedbackSummary,
	windowStart, windowEnd time.Time,
) (string, error) {
	// Build request
	taskRequest := c.buildTaskRequest(summary, windowStart, windowEnd)

	// Marshal to JSON
	jsonData, err := json.Marshal(taskRequest)
	if err != nil {
		return "", fmt.Errorf("failed to marshal request: %w", err)
	}

	// Send HTTP request
	response, err := c.sendRequest(ctx, jsonData)
	if err != nil {
		return "", err
	}

	// Validate response
	if response.Data.GID == "" {
		return "", fmt.Errorf("no task GID in response")
	}

	return response.Data.GID, nil
}

// sendRequest sends an HTTP request to Asana API
func (c *AsanaClient) sendRequest(ctx context.Context, jsonData []byte) (*AsanaTaskResponse, error) {
	// Create HTTP request
	url, err := url.JoinPath(c.baseURL, asanaTasksEndpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to build Asana URL: %w", err)
	}

	req, err := http.NewRequestWithContext(
		ctx,
		http.MethodPost,
		url,
		bytes.NewBuffer(jsonData),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create request to %s: %w", url, err)
	}

	// Set headers
	req.Header.Set("Authorization", "Bearer "+c.token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	// Send request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			slog.Warn("Failed to close response body", "error", err)
		}
	}()

	// Read response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	// Check status code
	if resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("asana API returned status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	var response AsanaTaskResponse
	if err := json.Unmarshal(body, &response); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	return &response, nil
}
