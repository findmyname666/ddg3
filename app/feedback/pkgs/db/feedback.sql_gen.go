// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feedback.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFeedbackBySentiment = `-- name: CountFeedbackBySentiment :one
SELECT 
    COUNT(*) FILTER (WHERE sentiment = 'positive') AS positive_count,
    COUNT(*) FILTER (WHERE sentiment = 'negative') AS negative_count
FROM feedback
WHERE created_at >= $1 AND created_at < $2
`

type CountFeedbackBySentimentParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

type CountFeedbackBySentimentRow struct {
	PositiveCount int64
	NegativeCount int64
}

func (q *Queries) CountFeedbackBySentiment(ctx context.Context, arg CountFeedbackBySentimentParams) (CountFeedbackBySentimentRow, error) {
	row := q.db.QueryRow(ctx, countFeedbackBySentiment, arg.CreatedAt, arg.CreatedAt_2)
	var i CountFeedbackBySentimentRow
	err := row.Scan(&i.PositiveCount, &i.NegativeCount)
	return i, err
}

const createFeedback = `-- name: CreateFeedback :one
INSERT INTO feedback (
    sentiment,
    message
) VALUES (
    $1, $2
) RETURNING id, created_at, sentiment, message
`

type CreateFeedbackParams struct {
	Sentiment SentimentType
	Message   pgtype.Text
}

func (q *Queries) CreateFeedback(ctx context.Context, arg CreateFeedbackParams) (Feedback, error) {
	row := q.db.QueryRow(ctx, createFeedback, arg.Sentiment, arg.Message)
	var i Feedback
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Sentiment,
		&i.Message,
	)
	return i, err
}

const deleteOldFeedback = `-- name: DeleteOldFeedback :exec
DELETE FROM feedback
WHERE created_at < $1
`

func (q *Queries) DeleteOldFeedback(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldFeedback, createdAt)
	return err
}

const getFeedback = `-- name: GetFeedback :one
SELECT id, created_at, sentiment, message FROM feedback
WHERE id = $1
`

func (q *Queries) GetFeedback(ctx context.Context, id int32) (Feedback, error) {
	row := q.db.QueryRow(ctx, getFeedback, id)
	var i Feedback
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Sentiment,
		&i.Message,
	)
	return i, err
}

const getFeedbackInTimeRange = `-- name: GetFeedbackInTimeRange :many
SELECT id, created_at, sentiment, message FROM feedback
WHERE created_at >= $1 AND created_at < $2
ORDER BY created_at DESC
`

type GetFeedbackInTimeRangeParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

func (q *Queries) GetFeedbackInTimeRange(ctx context.Context, arg GetFeedbackInTimeRangeParams) ([]Feedback, error) {
	rows, err := q.db.Query(ctx, getFeedbackInTimeRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feedback
	for rows.Next() {
		var i Feedback
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Sentiment,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedback = `-- name: ListFeedback :many
SELECT id, created_at, sentiment, message FROM feedback
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListFeedbackParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListFeedback(ctx context.Context, arg ListFeedbackParams) ([]Feedback, error) {
	rows, err := q.db.Query(ctx, listFeedback, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feedback
	for rows.Next() {
		var i Feedback
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Sentiment,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
