// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: report_runs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReportRun = `-- name: CreateReportRun :one
INSERT INTO report_runs (
    report_date,
    window_start,
    window_end,
    positive_count,
    negative_count,
    asana_task_gid
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING report_date, window_start, window_end, positive_count, negative_count, asana_task_gid, created_at
`

type CreateReportRunParams struct {
	ReportDate    pgtype.Date
	WindowStart   pgtype.Timestamptz
	WindowEnd     pgtype.Timestamptz
	PositiveCount int32
	NegativeCount int32
	AsanaTaskGid  pgtype.Text
}

func (q *Queries) CreateReportRun(ctx context.Context, arg CreateReportRunParams) (ReportRun, error) {
	row := q.db.QueryRow(ctx, createReportRun,
		arg.ReportDate,
		arg.WindowStart,
		arg.WindowEnd,
		arg.PositiveCount,
		arg.NegativeCount,
		arg.AsanaTaskGid,
	)
	var i ReportRun
	err := row.Scan(
		&i.ReportDate,
		&i.WindowStart,
		&i.WindowEnd,
		&i.PositiveCount,
		&i.NegativeCount,
		&i.AsanaTaskGid,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestReportRun = `-- name: GetLatestReportRun :one
SELECT report_date, window_start, window_end, positive_count, negative_count, asana_task_gid, created_at FROM report_runs
ORDER BY report_date DESC
LIMIT 1
`

func (q *Queries) GetLatestReportRun(ctx context.Context) (ReportRun, error) {
	row := q.db.QueryRow(ctx, getLatestReportRun)
	var i ReportRun
	err := row.Scan(
		&i.ReportDate,
		&i.WindowStart,
		&i.WindowEnd,
		&i.PositiveCount,
		&i.NegativeCount,
		&i.AsanaTaskGid,
		&i.CreatedAt,
	)
	return i, err
}

const getReportRun = `-- name: GetReportRun :one
SELECT report_date, window_start, window_end, positive_count, negative_count, asana_task_gid, created_at FROM report_runs
WHERE report_date = $1
`

func (q *Queries) GetReportRun(ctx context.Context, reportDate pgtype.Date) (ReportRun, error) {
	row := q.db.QueryRow(ctx, getReportRun, reportDate)
	var i ReportRun
	err := row.Scan(
		&i.ReportDate,
		&i.WindowStart,
		&i.WindowEnd,
		&i.PositiveCount,
		&i.NegativeCount,
		&i.AsanaTaskGid,
		&i.CreatedAt,
	)
	return i, err
}

const listReportRuns = `-- name: ListReportRuns :many
SELECT report_date, window_start, window_end, positive_count, negative_count, asana_task_gid, created_at FROM report_runs
ORDER BY report_date DESC
LIMIT $1 OFFSET $2
`

type ListReportRunsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListReportRuns(ctx context.Context, arg ListReportRunsParams) ([]ReportRun, error) {
	rows, err := q.db.Query(ctx, listReportRuns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReportRun
	for rows.Next() {
		var i ReportRun
		if err := rows.Scan(
			&i.ReportDate,
			&i.WindowStart,
			&i.WindowEnd,
			&i.PositiveCount,
			&i.NegativeCount,
			&i.AsanaTaskGid,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reportRunExists = `-- name: ReportRunExists :one
SELECT EXISTS(
    SELECT 1 FROM report_runs
    WHERE report_date = $1
)
`

func (q *Queries) ReportRunExists(ctx context.Context, reportDate pgtype.Date) (bool, error) {
	row := q.db.QueryRow(ctx, reportRunExists, reportDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateAsanaTaskGid = `-- name: UpdateAsanaTaskGid :exec
UPDATE report_runs
SET asana_task_gid = $2
WHERE report_date = $1
`

type UpdateAsanaTaskGidParams struct {
	ReportDate   pgtype.Date
	AsanaTaskGid pgtype.Text
}

func (q *Queries) UpdateAsanaTaskGid(ctx context.Context, arg UpdateAsanaTaskGidParams) error {
	_, err := q.db.Exec(ctx, updateAsanaTaskGid, arg.ReportDate, arg.AsanaTaskGid)
	return err
}
