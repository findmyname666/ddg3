services:
  # PostgreSQL Database
  postgres:
    image: ${acr_login_server}/${db_image_name}:${db_image_tag}
    container_name: ${app_name}-postgres-prod
    environment:
      DB_USER_MIGRATION_NAME: "$${DB_USER_MIGRATION_NAME}"
      DB_USER_MIGRATION_PASSWORD: "$${DB_USER_MIGRATION_PASSWORD}"
      DB_USER_WEB_NAME: "$${DB_USER_WEB_NAME}"
      DB_USER_WEB_PASSWORD: "$${DB_USER_WEB_PASSWORD}"
      DB_USER_ANALYSIS_NAME: "$${DB_USER_ANALYSIS_NAME}"
      DB_USER_ANALYSIS_PASSWORD: "$${DB_USER_ANALYSIS_PASSWORD}"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: $${DB_USER_POSTGRES_PASSWORD}
      POSTGRES_DB: feedback
      POSTGRES_INITDB_ARGS: --encoding=UTF-8
    # No ports exposed - only accessible via Docker network
    volumes:
      - postgres_data:/var/lib/postgresql
    networks:
      - ${app_name}-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 256M
        reservations:
          cpus: '0.5'
          memory: 128M
    restart: always

  # Database Migration (runs once before web starts)
  migration:
    image: ${acr_login_server}/${feedback_image_name}:${feedback_image_tag}
    container_name: ${app_name}-migration-prod
    environment:
      DEBUG: "true"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_DATABASE: feedback
      DB_SSLMODE: disable
      DB_USER: $${DB_USER_MIGRATION_NAME}
      DB_PASSWORD: $${DB_USER_MIGRATION_PASSWORD}
      MIGRATIONS_DIR: /app/db/migrations
    command: ["migrate"]
    networks:
      - ${app_name}-network
    depends_on:
      postgres:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M
        reservations:
          cpus: '0.25'
          memory: 64M
    restart: "no"

  # Web Application
  web:
    image: ${acr_login_server}/${feedback_image_name}:${feedback_image_tag}
    container_name: ${app_name}-web-prod
    environment:
      DEBUG: "false"
      WEB_HOST: "0.0.0.0"
      WEB_PORT: "8080"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_DATABASE: feedback
      DB_SSLMODE: disable
      DB_USER: $${DB_USER_WEB_NAME}
      DB_PASSWORD: $${DB_USER_WEB_PASSWORD}
      DB_MAX_CONNS: "25"
      DB_MIN_CONNS: "5"
      DB_MAX_CONN_LIFETIME: "1h"
      DB_MAX_CONN_IDLE_TIME: "30m"
      MAX_MESSAGE_LENGTH: "6666"
    # No ports exposed - only accessible via nginx
    networks:
      - ${app_name}-network
    depends_on:
      postgres:
        condition: service_healthy
      migration:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M
        reservations:
          cpus: '0.25'
          memory: 64M
    restart: always

  # Daily Analysis Job (run via systemd timer, not as a service)
  analysis:
    image: ${acr_login_server}/${feedback_image_name}:${feedback_image_tag}
    container_name: ${app_name}-analysis-prod
    environment:
      DEBUG: "false"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_DATABASE: feedback
      DB_SSLMODE: disable
      DB_USER: $${DB_USER_ANALYSIS_NAME}
      DB_PASSWORD: $${DB_USER_ANALYSIS_PASSWORD}
      ASANA_TOKEN: $${ASANA_TOKEN}
      ASANA_WORKSPACE_GID: $${ASANA_WORKSPACE_GID}
      ASANA_PROJECT_GID: $${ASANA_PROJECT_GID}
    command: ["analysis"]
    networks:
      - ${app_name}-network
    depends_on:
      postgres:
        condition: service_healthy
      migration:
        condition: service_completed_successfully
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M
        reservations:
          cpus: '0.25'
          memory: 64M
    restart: "no"  # Run via systemd timer, not as a persistent service
    profiles:
      - analysis  # Only start when explicitly requested

  # Nginx Reverse Proxy
  nginx:
    image: ${acr_login_server}/${nginx_image_name}:${nginx_image_tag}
    container_name: ${app_name}-nginx-prod
    environment:
      FQDN: ${fqdn}
    ports:
      # Port 80 is NOT exposed - certbot runs in standalone mode on host
      # HTTPS traffic: HTTP/2 (TCP) and HTTP/3 (UDP)
      - "443:443/tcp"   # HTTP/2 over TCP
      - "443:443/udp"   # HTTP/3 over QUIC (UDP)
    volumes:
      # Mount entire Let's Encrypt directory (includes archive for symlinks)
      - /etc/letsencrypt:/etc/letsencrypt:ro
    networks:
      - ${app_name}-network
    depends_on:
      - web
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M
        reservations:
          cpus: '0.25'
          memory: 64M
    restart: always

networks:
  ${app_name}-network:
    driver: bridge
    name: ${app_name}-network

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/db/postgresql
